<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>TaskPixel - ä»»åŠ¡è¯¦æƒ…</title>
  <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect" />
  <link as="style"
    href="https://fonts.googleapis.com/css2?display=swap&amp;family=Press+Start+2P&amp;family=VT323:wght@400&amp;family=Inter:wght@400;500;600;700&amp;subset=latin"
    onload="this.rel='stylesheet'" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
  <link rel="stylesheet" href="assets/css/styles.css">
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <script src="js/tailwind-config.js"></script>
  <!-- SortableJS for drag-and-drop ordering -->
  <script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    /* é¡µé¢ç‰¹å®šçš„æ ‡ç­¾ç›¸å…³æ ·å¼ */

    /* æ ‡ç­¾åŠŸèƒ½æ ·å¼ */
    .tags-input-container {
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 28px;
      position: relative;
    }

    .add-tags-btn {
      font-family: 'VT323', monospace;
      font-size: 12px;
      border: none;
      background: transparent;
      color: #4F46E5;
      padding: 2px 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .add-tags-btn:hover {
      background: #4F46E5;
      color: white;
      box-shadow: 0 0 8px #4F46E5;
    }

    .tag-input-wrapper {
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .tag-input-field {
      font-family: 'VT323', monospace;
      font-size: 14px;
      border: 2px solid #4F46E5;
      padding: 4px 8px;
      background: white;
      color: #212121;
      min-width: 120px;
      outline: none;
    }

    .tag-input-field:focus {
      box-shadow: 0 0 8px #4F46E5;
    }

    .tag-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 2px solid #4F46E5;
      border-top: none;
      max-height: 120px;
      overflow-y: auto;
      z-index: 10;
    }

    .tag-suggestion-item {
      padding: 4px 8px;
      font-family: 'VT323', monospace;
      font-size: 14px;
      cursor: pointer;
      border-bottom: 1px solid #e5e7eb;
    }

    .tag-suggestion-item:hover,
    .tag-suggestion-item.selected {
      background: #4F46E5;
      color: white;
    }

    .tag-suggestion-item:last-child {
      border-bottom: none;
    }

    .task-tag {
      font-family: 'VT323', monospace;
      font-size: 14px;
      font-weight: bold;
      margin-right: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-user-select: none;
      user-select: none;
    }

    .task-tag:hover {
      text-shadow: 0 0 8px currentColor;
      transform: scale(1.05);
    }

    .task-tag:hover::after {
      content: ' Ã—';
      color: #ef4444;
      font-weight: bold;
    }

    /* æŠ˜å å­æ­¥éª¤æ ·å¼ */
    .toggle-substeps-btn {
      border: 2px solid transparent;
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
    }

    .toggle-substeps-btn:focus {
      outline: 2px dashed #4F46E5;
      outline-offset: 3px;
    }

    .substeps-container[data-collapsed="true"] {
      display: none;
    }

    /* ä¿è¯æ ‡ç­¾æ˜¾ç¤ºåŒºåŸŸå’Œ +Tags æŒ‰é’®åœ¨åŒä¸€è¡Œï¼ˆåœ¨çª„å±ä¸‹å›é€€ä¸ºå‚ç›´å¸ƒå±€ï¼‰ */
    .task-tags-section .task-tags-display,
    .goal-tags-section .goal-tags-display {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      flex: 1 1 auto;
      min-width: 0;
      /* allow flex children to shrink */
      overflow-x: auto;
    }

    .task-tags-section .tags-input-container,
    .goal-tags-section .tags-input-container {
      flex: 0 0 auto;
      margin-left: 0.5rem;
    }

    /* å°å±å¹•ï¼šè®© tags åŒºåŸŸå æ»¡ä¸€è¡Œï¼ŒæŒ‰é’®å›åˆ°ä¸‹ä¸€è¡Œä»¥é¿å…æ‹¥æŒ¤ */
    @media (max-width: 640px) {

      .task-tags-section .task-tags-display,
      .goal-tags-section .goal-tags-display {
        display: block;
        width: 100%;
      }

      .task-tags-section .tags-input-container,
      .goal-tags-section .tags-input-container {
        display: block;
        margin-left: 0;
        margin-top: 0.5rem;
      }
    }

    .task-tags-section {
      border-top: 1px dashed #ccc;
      border-bottom: 1px dashed #ccc;
      padding: 12px 0;
    }

    .goal-tags-section {
      border-top: 1px dashed #e5e7eb;
      padding-top: 8px;
      margin-bottom: 12px;
    }
  </style>
</head>

<body class="bg-background">
  <div class="flex h-full min-h-screen w-full flex-col font-body">
    <header
      class="flex items-center justify-between whitespace-nowrap border-b-4 border-pixel-border-color px-6 py-4 bg-white">
      <div class="flex items-center gap-4">
        <svg class="text-pixel-text-color" fill="none" height="32" viewBox="0 0 32 32" width="32"
          xmlns="http://www.w3.org/2000/svg">
          <path clip-rule="evenodd"
            d="M0 0H8V8H0V0ZM8 8H16V16H8V8ZM16 16H24V24H16V16ZM0 16H8V24H0V16ZM8 24H16V32H8V24ZM16 0H24V8H16V0ZM24 8H32V16H24V8Z"
            fill="currentColor" fill-rule="evenodd"></path>
        </svg>
        <h2 class="text-xl font-bold text-pixel-text-color">TaskPixel</h2>
      </div>
      <div class="hidden md:flex items-center gap-8 text-sm nav-links">
        <a class="text-black/70 hover:text-primary nav-link" href="index.html">ä¸»é¡µ</a>
        <a class="text-black/70 hover:text-primary nav-link" href="#">æ—¥å†</a>
        <a class="text-black/70 hover:text-primary nav-link" href="goals.html">ç›®æ ‡</a>
        <a class="text-black/70 hover:text-primary nav-link" href="tags_management.html">æ ‡ç­¾ç®¡ç†</a>
        <a class="text-black/70 hover:text-primary nav-link" href="settings.html">è®¾ç½®</a>
        <a class="text-black/70 hover:text-primary nav-link" href="data_management.html">æ•°æ®ç®¡ç†</a>
      </div>
    </header>
    <main class="w-full flex-1 p-4 sm:p-6 md:p-10">
      <div class="mx-auto max-w-7xl">
        <!-- å·¦å³ä¸¤æ å¸ƒå±€ -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

          <!-- å·¦ä¾§æ  -->
          <div class="space-y-8">
            <!-- ä»»åŠ¡å¡ç‰‡ -->
            <div class="pixel-border p-6 panel-bg">
              <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4">
                <h2 class="font-display text-2xl text-text-primary mb-4 sm:mb-0 task-title"></h2>
                <div class="flex items-center gap-2">
                  <span
                    class="font-display text-sm px-2 py-1 task-status bg-accent-yellow/20 text-accent-yellow-800 border-2 border-accent-yellow-800">è¿›è¡Œä¸­</span>
                </div>
              </div>
              <div class="space-y-6">
                <div>
                  <label class="block font-display text-lg text-text-primary mb-2" for="task-description">æè¿°</label>
                  <p class="text-xl text-text-secondary task-description"></p>
                </div>
                <!-- æ ‡ç­¾åŒºåŸŸ -->
                <div class="task-tags-section mt-4">
                  <div class="flex items-center gap-2 flex-wrap">
                    <div class="task-tags-display flex flex-wrap gap-1">
                      <!-- ä»»åŠ¡æ ‡ç­¾æ˜¾ç¤ºåŒºåŸŸ -->
                    </div>
                    <div class="tags-input-container" data-target="task" data-task-id="">
                      <button class="add-tags-btn">+Tags</button>
                      <div class="tag-input-wrapper hidden">
                        <input type="text" class="tag-input-field" placeholder="è¾“å…¥æ ‡ç­¾åç§°..." autocomplete="off">
                        <div class="tag-suggestions hidden"></div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="mt-4">
                  <label class="block font-display text-lg text-text-primary mb-2" for="task-progress">è¿›åº¦</label>
                  <div class="progress-bar with-text">
                    <div class="progress-bar-fill"></div>
                    <div class="progress-label" aria-hidden="true"></div>
                  </div>
                  <p class="text-right text-text-secondary text-lg mt-1 progress-text"></p>
                </div>
              </div>
              <div class="mt-8 flex items-center justify-end gap-4">
                <button
                  class="pixel-button back-button bg-pixel-secondary text-text-primary font-display py-2 px-4 text-sm flex items-center"
                  title="è¿”å›">
                  <span class="material-symbols-outlined align-middle">arrow_back</span>
                </button>
                <button
                  class="pixel-button edit-button bg-accent-blue text-white font-display py-2 px-4 text-sm flex items-center"
                  title="ç¼–è¾‘ä»»åŠ¡">
                  <span class="material-symbols-outlined align-middle">edit</span>
                </button>
                <button
                  class="pixel-button complete-button bg-accent-green text-white font-display py-2 px-4 text-sm flex items-center"
                  title="æ ‡è®°ä¸ºå®Œæˆ">
                  <span class="material-symbols-outlined align-middle">check_circle</span>
                </button>
              </div>
            </div>

            <!-- ç›®æ ‡å’Œå­æ­¥éª¤ -->
            <div class="pixel-border p-6 panel-bg">
              <div class="space-y-6 goals-container">
                <!-- ç›®æ ‡å’Œå­æ­¥éª¤å°†é€šè¿‡JavaScriptåŠ¨æ€æ¸²æŸ“ -->
              </div>
            </div>
          </div>

          <!-- å³ä¾§æ  -->
          <div class="space-y-8">
            <!-- è®°å½•å·¥ä½œè¿›åº¦ -->
            <div class="pixel-border p-6 panel-bg">
              <h3 class="font-display text-2xl text-text-primary mb-6">è®°å½•å·¥ä½œè¿›åº¦</h3>
              <form id="timeline-form" class="space-y-6">
                <div>
                  <label class="block font-display text-lg text-text-primary mb-2" for="work-content">å·¥ä½œå†…å®¹</label>
                  <textarea id="work-content" placeholder="æè¿°æ‚¨çš„å·¥ä½œ..." rows="4"></textarea>
                </div>
                <div>
                  <label class="block font-display text-lg text-text-primary mb-2" for="time-spent">æ—¶é—´ (å°æ—¶)</label>
                  <input id="time-spent" placeholder="å¦‚ï¼š2" type="number" step="0.1" min="0.1" />
                </div>
                <div>
                  <button type="submit"
                    class="pixel-button w-full bg-accent-green text-white font-display py-3 px-4 text-sm flex items-center justify-center gap-2"
                    title="è®°å½•è¿›åº¦">
                    <span>ğŸ’¾</span>
                    <span>è®°å½•è¿›åº¦</span>
                  </button>
                </div>
              </form>
            </div>

            <!-- è¿›åº¦å†å² -->
            <div class="pixel-border p-6 panel-bg">
              <h3 class="font-display text-2xl text-text-primary mb-6">è¿›åº¦å†å²</h3>
              <div class="space-y-4 timeline-container">
                <!-- æ—¶é—´çº¿è®°å½•å°†é€šè¿‡JavaScriptåŠ¨æ€æ¸²æŸ“ -->
              </div>
            </div>
          </div>

        </div>
      </div>
    </main>
  </div>

  <script>
    // ç¡®ä¿ TaskPixel åç§°ç©ºé—´å­˜åœ¨ï¼Œå³ä½¿ core.js æœªèƒ½æ­£ç¡®åŠ è½½
    window.TaskPixel = window.TaskPixel || {};

    // ç»Ÿä¸€çš„ç¼–è¾‘ä»»åŠ¡å‡½æ•°
    function editTask(taskId) {
      if (!taskId) {
        alert('æœªæ‰¾åˆ°ä»»åŠ¡ID');
        return;
      }

      let data, task;

      try {
        const raw = localStorage.getItem('taskpixel_data');
        if (!raw) {
          alert('æœªæ‰¾åˆ°ä»»åŠ¡æ•°æ®');
          return;
        }

        data = JSON.parse(raw);
        task = data.tasks.find(t => t.id === taskId);

        if (!task) {
          alert('æœªæ‰¾åˆ°æŒ‡å®šä»»åŠ¡');
          return;
        }

      } catch (parseError) {
        console.error('è¯»å–ä»»åŠ¡æ•°æ®é”™è¯¯:', parseError);
        alert('è¯»å–ä»»åŠ¡æ•°æ®å¤±è´¥: ' + parseError.message);
        return;
      }

      try {
        // åˆ›å»ºç¼–è¾‘å¯¹è¯æ¡†
        const dialogElement = document.createElement('div');
        dialogElement.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
        dialogElement.id = 'edit-task-dialog';

        // è®¡ç®—å½“å‰è¿›åº¦ï¼Œå†³å®šçŠ¶æ€é€‰é¡¹
        let currentProgress = window.TaskPixel?.DataStoreAdapter?.getTaskProgress(taskId) || task.progress || 0;
        let currentStatus = task.status || 'in-progress';
        let isCompleted = currentProgress >= 100;

        dialogElement.innerHTML = `
          <div class="pixel-border bg-white p-6 w-full max-w-lg">
            <h2 class="text-2xl font-display mb-6">ç¼–è¾‘ä»»åŠ¡</h2>
            <form id="edit-task-form">
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="edit-task-title">ä»»åŠ¡æ ‡é¢˜</label>
                <input type="text" id="edit-task-title" class="w-full" required placeholder="è¾“å…¥ä»»åŠ¡æ ‡é¢˜" value="${task.title || ''}">
              </div>
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="edit-task-description">ä»»åŠ¡æè¿°</label>
                <textarea id="edit-task-description" class="w-full h-32" placeholder="è¾“å…¥ä»»åŠ¡æè¿°">${task.description || ''}</textarea>
              </div>
              ${isCompleted ? `
              <div class="mb-4">
                <label class="block font-display text-lg mb-2">çŠ¶æ€</label>
                <div class="w-full p-2 bg-green-100 text-green-800 border border-green-300 rounded">
                  âœ… å·²å®Œæˆï¼ˆè¿›åº¦100%ï¼Œè‡ªåŠ¨è®¾ç½®ï¼‰
                </div>
              </div>
              ` : `
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="edit-task-status">çŠ¶æ€</label>
                <select id="edit-task-status" class="w-full">
                  <option value="in-progress" ${currentStatus === 'in-progress' || currentStatus === 'todo' ? 'selected' : ''}>è¿›è¡Œä¸­</option>
                  <option value="on-hold" ${currentStatus === 'on-hold' ? 'selected' : ''}>æç½®</option>
                </select>
              </div>
              `}
              <div class="mb-4">
                <label class="block font-display text-lg mb-2">å½“å‰è¿›åº¦: ${currentProgress}%</label>
                <div class="w-full bg-gray-200 rounded-full h-2">
                  <div class="bg-blue-600 h-2 rounded-full" style="width: ${currentProgress}%"></div>
                </div>
              </div>
              <div class="flex justify-end gap-4">
                <button type="button" id="cancel-edit-task" class="pixel-button">å–æ¶ˆ</button>
                <button type="submit" class="pixel-button bg-primary text-white">ä¿å­˜</button>
              </div>
            </form>
          </div>
        `;

        document.body.appendChild(dialogElement);

        // ç»‘å®šè¡¨å•æäº¤äº‹ä»¶
        document.getElementById('edit-task-form').addEventListener('submit', function (e) {
          e.preventDefault();

          try {
            const title = document.getElementById('edit-task-title').value.trim();
            const description = document.getElementById('edit-task-description').value.trim();

            if (!title) {
              alert('ä»»åŠ¡æ ‡é¢˜ä¸èƒ½ä¸ºç©º');
              return;
            }

            // ç¡®å®šæœ€ç»ˆçŠ¶æ€
            let finalStatus;
            const progress = window.TaskPixel?.DataStoreAdapter?.getTaskProgress(taskId) || task.progress || 0;

            if (progress >= 100) {
              finalStatus = 'completed';
            } else {
              const statusSelect = document.getElementById('edit-task-status');
              finalStatus = statusSelect ? statusSelect.value : 'in-progress';
            }

            // æ›´æ–°ä»»åŠ¡æ•°æ®
            task.title = title;
            task.description = description;
            task.status = finalStatus;

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('taskpixel_data', JSON.stringify(data));

            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            alert('ä»»åŠ¡æ›´æ–°æˆåŠŸï¼');

            // å…³é—­å¯¹è¯æ¡†
            const dialogElement = document.getElementById('edit-task-dialog');
            if (dialogElement) {
              dialogElement.remove();
            }

            // åˆ·æ–°é¡µé¢
            location.reload();

          } catch (submitError) {
            console.error('è¡¨å•æäº¤é”™è¯¯:', submitError);
            alert('ä¿å­˜ä»»åŠ¡æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•ï¼š' + submitError.message);
          }
        });

        // ç»‘å®šå–æ¶ˆæŒ‰é’®
        document.getElementById('cancel-edit-task').addEventListener('click', function () {
          const dialogElement = document.getElementById('edit-task-dialog');
          if (dialogElement) {
            dialogElement.remove();
          }
        });

      } catch (dialogError) {
        console.error('åˆ›å»ºç¼–è¾‘å¯¹è¯æ¡†é”™è¯¯:', dialogError);
        alert('åˆ›å»ºç¼–è¾‘å¯¹è¯æ¡†å¤±è´¥: ' + dialogError.message);
      }
    }

    // ç»Ÿä¸€çš„å®Œæˆä»»åŠ¡å‡½æ•°
    function completeTask(taskId) {
      if (!taskId) {
        alert('æœªæ‰¾åˆ°ä»»åŠ¡ID');
        return;
      }

      try {
        const raw = localStorage.getItem('taskpixel_data');
        if (!raw) {
          alert('æœªæ‰¾åˆ°ä»»åŠ¡æ•°æ®');
          return;
        }

        const data = JSON.parse(raw);
        const task = data.tasks.find(t => t.id === taskId);

        if (!task) {
          alert('æœªæ‰¾åˆ°æŒ‡å®šä»»åŠ¡');
          return;
        }

        // åˆ‡æ¢å®ŒæˆçŠ¶æ€
        const oldStatus = task.status;
        task.status = task.status === 'completed' ? 'in-progress' : 'completed';

        // å¦‚æœæ ‡è®°ä¸ºå®Œæˆï¼Œè®¾ç½®è¿›åº¦ä¸º100%
        if (task.status === 'completed') {
          task.progress = 100;
        }

        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('taskpixel_data', JSON.stringify(data));

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        const statusText = task.status === 'completed' ? 'å·²å®Œæˆ' : 'è¿›è¡Œä¸­';
        alert(`ä»»åŠ¡çŠ¶æ€å·²æ›´æ–°ä¸ºï¼š${statusText}`);

        // åˆ·æ–°é¡µé¢
        location.reload();

      } catch (e) {
        console.error('æ›´æ–°ä»»åŠ¡çŠ¶æ€é”™è¯¯:', e);
        alert('æ›´æ–°ä»»åŠ¡çŠ¶æ€æ—¶å‡ºé”™: ' + e.message);
      }
    }

    // æ·»åŠ å·¥ä½œè¿›åº¦è®°å½•
    function addWorkProgress(taskId, content, hours) {
      if (!taskId) {
        alert('æœªæ‰¾åˆ°ä»»åŠ¡ID');
        return;
      }

      try {
        const raw = localStorage.getItem('taskpixel_data');
        if (!raw) {
          alert('æœªæ‰¾åˆ°ä»»åŠ¡æ•°æ®');
          return;
        }

        const data = JSON.parse(raw);
        const task = data.tasks.find(t => t.id === taskId);

        if (!task) {
          alert('æœªæ‰¾åˆ°æŒ‡å®šä»»åŠ¡');
          return;
        }

        // åˆå§‹åŒ–timelineæ•°ç»„
        if (!task.timeline) {
          task.timeline = [];
        }

        // åˆ›å»ºæ–°çš„è¿›åº¦è®°å½•
        const progressEntry = {
          id: 'progress-' + Date.now(),
          date: new Date().toISOString(),
          content: content,
          hours: hours,
          timestamp: Date.now()
        };

        task.timeline.push(progressEntry);

        // æ›´æ–°æ€»å·¥ä½œæ—¶é—´
        const totalHours = task.timeline.reduce((sum, entry) => sum + (entry.hours || 0), 0);
        task.totalHours = totalHours;

        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('taskpixel_data', JSON.stringify(data));

        // æ¸…ç©ºè¡¨å•
        document.getElementById('work-content').value = '';
        document.getElementById('time-spent').value = '';

        // é‡æ–°æ¸²æŸ“è¿›åº¦å†å²
        renderProgressHistory(task.timeline);

        alert('å·¥ä½œè¿›åº¦è®°å½•æˆåŠŸï¼');

      } catch (e) {
        alert('è®°å½•å·¥ä½œè¿›åº¦æ—¶å‡ºé”™: ' + e.message);
      }
    }

    // æ¸²æŸ“è¿›åº¦å†å²
    function renderProgressHistory(timeline) {
      const container = document.querySelector('.timeline-container');
      if (!container) return;

      container.innerHTML = '';

      if (!timeline || timeline.length === 0) {
        container.innerHTML = `
          <div class="text-center py-8">
            <p class="text-gray-500 mb-4">è¿˜æ²¡æœ‰å·¥ä½œè¿›åº¦è®°å½•</p>
            <p class="text-gray-400 text-sm">å¼€å§‹è®°å½•æ‚¨çš„å·¥ä½œè¿›åº¦å§ï¼</p>
          </div>
        `;
        return;
      }

      // æŒ‰æ—¶é—´å€’åºæ’åˆ—
      const sortedTimeline = [...timeline].sort((a, b) => b.timestamp - a.timestamp);

      sortedTimeline.forEach(entry => {
        const entryElement = document.createElement('div');
        entryElement.className = 'pixel-border bg-white p-4 mb-4 hover:shadow-lg transition-shadow';

        const date = new Date(entry.date);
        const formattedDate = date.toLocaleDateString('zh-CN') + ' ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        entryElement.innerHTML = `
          <div class="flex justify-between items-start mb-3">
            <div class="flex items-center gap-2">
              <div class="w-3 h-3 bg-primary"></div>
              <span class="font-display text-sm text-gray-600">${formattedDate}</span>
            </div>
            <span class="pixel-button bg-primary text-white px-3 py-1 text-xs">${entry.hours} å°æ—¶</span>
          </div>
          <div class="pl-5">
            <p class="font-display text-lg text-text-primary">${entry.content}</p>
          </div>
        `;

        container.appendChild(entryElement);
      });
    }
  </script>
  <script src="js/core.js"></script>
  <script src="js/dataStoreAdapter.js"></script>
  <script src="js/tagManager.js"></script>
  <script src="js/aiAssist.js"></script>
  <script src="js/taskDetail.js"></script>
  <script>
    // ç®€åŒ–çš„åˆå§‹åŒ–è„šæœ¬ - ç§»é™¤æ‰€æœ‰è°ƒè¯•è¾“å‡º
    document.addEventListener('DOMContentLoaded', function () {
      // åŸºç¡€æŒ‰é’®äº‹ä»¶
      document.querySelector('.back-button')?.addEventListener('click', function () {
        window.location.href = 'index.html';
      });

      document.querySelector('.edit-button')?.addEventListener('click', function () {
        const taskId = new URLSearchParams(window.location.search).get('id') || window.currentTaskId;
        editTask(taskId);
      });

      document.querySelector('.complete-button')?.addEventListener('click', function () {
        const taskId = new URLSearchParams(window.location.search).get('id');
        completeTask(taskId);
      });

      // è®°å½•å·¥ä½œè¿›åº¦è¡¨å•å¤„ç†
      document.getElementById('timeline-form')?.addEventListener('submit', function (e) {
        e.preventDefault();
        const taskId = new URLSearchParams(window.location.search).get('id');
        const workContent = document.getElementById('work-content').value.trim();
        const timeSpent = parseFloat(document.getElementById('time-spent').value);

        if (!workContent) {
          alert('è¯·è¾“å…¥å·¥ä½œå†…å®¹');
          return;
        }
        if (!timeSpent || timeSpent <= 0) {
          alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å·¥ä½œæ—¶é—´');
          return;
        }

        addWorkProgress(taskId, workContent, timeSpent);
      });

      // åˆå§‹åŒ– TaskPixel
      try {
        if (typeof TaskPixel?.init === 'function') {
          TaskPixel.init();
        }
      } catch (e) {
        // é™é»˜å¤„ç†é”™è¯¯
      }

      // åˆå§‹åŒ– TaskDetail
      try {
        const taskId = new URLSearchParams(window.location.search).get('id');
        if (taskId && window.TaskPixel?.TaskDetail?.init) {
          window.currentTaskId = taskId;
          TaskPixel.TaskDetail.currentTaskId = taskId;
          TaskPixel.TaskDetail.init();
        }
      } catch (e) {
        // é™é»˜å¤„ç†é”™è¯¯
      }

      // å†…è”æ ‡ç­¾ç®¡ç†å™¨å°†åœ¨å®šä¹‰ååˆå§‹åŒ–

      // å¤‡ç”¨æ•°æ®æ˜¾ç¤ºé€»è¾‘ - ç¡®ä¿ä»»åŠ¡ä¿¡æ¯èƒ½å¤Ÿæ˜¾ç¤º
      setTimeout(function () {
        const taskId = new URLSearchParams(window.location.search).get('id');
        if (taskId) {
          try {
            const raw = localStorage.getItem('taskpixel_data');
            if (raw) {
              const data = JSON.parse(raw);
              const task = (data.tasks || []).find(t => t.id === taskId);

              if (task) {
                // æ›´æ–°æ ‡é¢˜
                const titleEl = document.querySelector('.task-title');
                if (titleEl && !titleEl.textContent.includes(task.title)) {
                  titleEl.textContent = 'ä»»åŠ¡: ' + task.title;
                }

                // è®¾ç½®ä»»åŠ¡æ ‡ç­¾å®¹å™¨çš„ task-id
                const taskTagContainer = document.querySelector('[data-target="task"]');
                if (taskTagContainer) {
                  taskTagContainer.dataset.taskId = taskId;
                }

                // æ¸²æŸ“ä»»åŠ¡æ ‡ç­¾ï¼ˆä»…åœ¨å®¹å™¨ä¸ºç©ºæ—¶ï¼‰
                const taskTagsDisplay = document.querySelector('.task-tags-display');
                if (typeof InlineTagManager !== 'undefined' && InlineTagManager.renderTaskTags &&
                  taskTagsDisplay && taskTagsDisplay.children.length === 0) {
                  InlineTagManager.renderTaskTags(taskId);
                }

                // æ›´æ–°æè¿°
                const descEl = document.querySelector('.task-description');
                if (descEl && !descEl.textContent) {
                  descEl.textContent = task.description || 'æš‚æ— æè¿°';
                }

                // æ›´æ–°è¿›åº¦ - ä½¿ç”¨ç»Ÿä¸€çš„ updateProgressBar å‡½æ•°
                updateProgressBar(taskId);

                // æ›´æ–°çŠ¶æ€
                const statusEl = document.querySelector('.task-status');
                if (statusEl) {
                  let statusText = 'è¿›è¡Œä¸­';
                  let statusClass = 'bg-accent-yellow/20 text-accent-yellow-800 border-accent-yellow-800';

                  switch (task.status) {
                    case 'todo':
                      statusText = 'å¾…å¤„ç†';
                      statusClass = 'bg-accent-blue/20 text-accent-blue-800 border-accent-blue-800';
                      break;
                    case 'on-hold':
                      statusText = 'æç½®';
                      statusClass = 'bg-accent-red/20 text-accent-red-800 border-accent-red-800';
                      break;
                    case 'completed':
                      statusText = 'å·²å®Œæˆ';
                      statusClass = 'bg-accent-green/20 text-accent-green-800 border-accent-green-800';
                      break;
                    case 'in-progress':
                    default:
                      statusText = 'è¿›è¡Œä¸­';
                      statusClass = 'bg-accent-yellow/20 text-accent-yellow-800 border-accent-yellow-800';
                      break;
                  }
                  statusEl.textContent = statusText;

                  // æ›´æ–°çŠ¶æ€æ ·å¼
                  statusEl.className = `font-display text-sm px-2 py-1 task-status border-2 ${statusClass}`;
                }

                // æ¸²æŸ“ç›®æ ‡
                const goalsContainer = document.querySelector('.goals-container');
                if (goalsContainer) {
                  renderGoals(task.goals || [], taskId);
                  // æ¸²æŸ“ç›®æ ‡åæ›´æ–°è¿›åº¦æ¡
                  updateProgressBar(taskId);
                }

                // æ¸²æŸ“è¿›åº¦å†å²
                if (task.timeline) {
                  renderProgressHistory(task.timeline);
                }
              }
            }
          } catch (e) {
            // é™é»˜å¤„ç†é”™è¯¯
          }
        }
      }, 1000);

      // ç›®æ ‡æ¸²æŸ“å‡½æ•°
      function renderGoals(goals, taskId) {
        const goalsContainer = document.querySelector('.goals-container');
        if (!goalsContainer) return;

        // æ¸…ç©ºå®¹å™¨
        goalsContainer.innerHTML = '';

        // æ·»åŠ æ ‡é¢˜å’ŒAIåŠ©æ‰‹æŒ‰é’®
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between mb-6';
        header.innerHTML = `
          <h3 class="font-display text-2xl text-text-primary">ç›®æ ‡ä¸å­æ­¥éª¤</h3>
          <button class="pixel-button bg-purple-600 text-white px-4 py-2 text-sm">
            <span class="mr-2">âœ¨</span>AI åŠ©æ‰‹
          </button>
        `;
        goalsContainer.appendChild(header);

        // æ¸²æŸ“ç›®æ ‡åˆ—è¡¨
        if (goals && goals.length > 0) {
          goals.forEach(goal => {
            const goalCard = createGoalCard(goal, taskId);
            goalsContainer.appendChild(goalCard);

            // æ¸²æŸ“ç›®æ ‡æ ‡ç­¾ï¼ˆä»…åœ¨å®¹å™¨ä¸ºç©ºæ—¶ï¼‰
            const goalTagsDisplay = goalCard.querySelector('.goal-tags-display');
            if (typeof InlineTagManager !== 'undefined' && InlineTagManager.renderGoalTags &&
              goalTagsDisplay && goalTagsDisplay.children.length === 0) {
              InlineTagManager.renderGoalTags(goal.id);
            }
          });

          // æ·»åŠ "æ·»åŠ æ–°ç›®æ ‡"æŒ‰é’®
          const addButton = document.createElement('div');
          addButton.className = 'text-center mt-6';
          addButton.innerHTML = `
            <button class="pixel-button bg-primary text-white px-4 py-2 add-goal-btn" title="æ·»åŠ æ–°ç›®æ ‡">ğŸ¯ â•</button>
          `;
          goalsContainer.appendChild(addButton);
        } else {
          // ç©ºçŠ¶æ€
          const emptyState = document.createElement('div');
          emptyState.className = 'text-center py-8';
          emptyState.innerHTML = `
            <p class="text-gray-500 mb-4">è¿˜æ²¡æœ‰è®¾ç½®ç›®æ ‡</p>
            <button class="pixel-button bg-primary text-white px-4 py-2 add-goal-btn" title="æ·»åŠ ç›®æ ‡">ğŸ¯ â•</button>
          `;
          goalsContainer.appendChild(emptyState);
        }

        // ç»‘å®šæ·»åŠ ç›®æ ‡æŒ‰é’®
        bindAddGoalEvents(taskId);

        // åº”ç”¨å·²ä¿å­˜çš„æŠ˜å é¦–é€‰é¡¹ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¹¶åˆå§‹åŒ–å­æ­¥éª¤çš„ Sortable å®ä¾‹
        try {
          const raw = localStorage.getItem('taskpixel_ui');
          const prefs = raw ? JSON.parse(raw) : {};
          const collapsed = (prefs && prefs.collapsedGoals) ? prefs.collapsedGoals[taskId] || {} : {};
          document.querySelectorAll('.substeps-wrapper').forEach(wrapper => {
            const gid = wrapper.dataset.goalId;
            const container = wrapper.querySelector('.substeps-container');
            if (!container) return;
            const isCollapsed = !!collapsed[gid];
            container.setAttribute('data-collapsed', isCollapsed ? 'true' : 'false');
            container.style.display = isCollapsed ? 'none' : '';
            const toggle = wrapper.querySelector('.toggle-substeps-btn');
            if (toggle) toggle.textContent = isCollapsed ? 'â–¸' : 'â–¾';
          });

          // åˆå§‹åŒ–æ¨¡å—åŒ– TaskDetail çš„å­æ­¥éª¤ sortableï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (window.TaskPixel && TaskPixel.TaskDetail && typeof TaskPixel.TaskDetail.attachSubstepsSortables === 'function') {
            TaskPixel.TaskDetail.attachSubstepsSortables();
          }
        } catch (e) {
          console.error('åº”ç”¨æŠ˜å é¦–é€‰é¡¹/åˆå§‹åŒ–å­æ­¥éª¤ sortable æ—¶å‡ºé”™', e);
        }
      }

      // åˆ›å»ºç›®æ ‡å¡ç‰‡
      function createGoalCard(goal, taskId) {
        const card = document.createElement('div');
        card.className = 'border-4 border-black bg-white mb-6 p-4 goal-card';
        card.dataset.goalId = goal.id;

        // è®¡ç®—è¿›åº¦
        const total = goal.substeps ? goal.substeps.length : 0;
        const completed = goal.substeps ? goal.substeps.filter(s => s.completed).length : 0;

        card.innerHTML = `
          <div class="flex items-start justify-between mb-4">
              <div class="flex items-center gap-2">
                <button class="pixel-button-flat bg-gray-200 text-black px-3 py-1 text-xs move-goal-up" data-goal-id="${goal.id}" title="ä¸Šç§»ç›®æ ‡">â†‘</button>
                <button class="pixel-button-flat bg-gray-200 text-black px-3 py-1 text-xs move-goal-down" data-goal-id="${goal.id}" title="ä¸‹ç§»ç›®æ ‡">â†“</button>
              </div>
              <div class="flex-1">
              <div class="flex items-center justify-between">
                <h4 class="font-display text-lg font-bold mb-2">${goal.title || 'æœªå‘½åç›®æ ‡'}</h4>
                <button class="toggle-substeps-btn pixel-button-flat bg-transparent text-black px-2 py-1 text-sm" data-goal-id="${goal.id}" title="å±•å¼€/æŠ˜å å­æ­¥éª¤">â–¾</button>
              </div>
              <p class="text-gray-600 text-sm mb-2">${goal.description || ''}</p>
            </div>
            <div class="flex gap-2">
              <button class="pixel-button-flat bg-green-500 text-white px-3 py-1 text-xs edit-goal-btn" 
                      data-goal-id="${goal.id}" title="ä¿®æ”¹ç›®æ ‡">âœï¸</button>
              <button class="pixel-button-flat bg-blue-500 text-white px-3 py-1 text-xs add-substep-btn" 
                      data-goal-id="${goal.id}" title="æ·»åŠ å­æ­¥éª¤">â•</button>
              <button class="pixel-button-flat bg-red-500 text-white px-3 py-1 text-xs delete-goal-btn" 
                      data-goal-id="${goal.id}" title="åˆ é™¤ç›®æ ‡">ğŸ—‘ï¸</button>
            </div>
          </div>

          <!-- ç›®æ ‡æ ‡ç­¾åŒºåŸŸï¼ˆæ ‡ç­¾æ˜¾ç¤ºåŒºä¸ +Tags æŒ‰é’®åŒè¡Œï¼Œçª„å±å›é€€ï¼‰ -->
          <div class="goal-tags-section mt-2 mb-3">
            <div class="flex items-center gap-2 flex-wrap">
              <div class="goal-tags-display flex flex-wrap gap-1">
                <!-- ç›®æ ‡æ ‡ç­¾æ˜¾ç¤ºåŒºåŸŸ -->
              </div>
              <div class="tags-input-container" data-target="goal" data-goal-id="${goal.id}" data-task-id="${taskId}">
                <button class="add-tags-btn">+Tags</button>
                <div class="tag-input-wrapper hidden">
                  <input type="text" class="tag-input-field" placeholder="è¾“å…¥æ ‡ç­¾..." autocomplete="off">
                  <div class="tag-suggestions hidden"></div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="substeps-wrapper" data-goal-id="${goal.id}">
            <div class="substeps-container" role="region" aria-label="å­æ­¥éª¤åˆ—è¡¨" data-collapsed="false">
            ${goal.substeps ? goal.substeps.map(substep => `
              <div class="flex items-center gap-3 py-2 px-3 hover:bg-gray-50 substep-item" data-substep-id="${substep.id}">
                <input type="checkbox" ${substep.completed ? 'checked' : ''} 
                       class="substep-checkbox w-4 h-4" 
                       data-goal-id="${goal.id}" 
                       data-substep-id="${substep.id}">
                <span class="flex-1 ${substep.completed ? 'line-through text-gray-500' : ''}">${substep.content || substep.title}</span>
                <div class="flex gap-1 items-center">
                  <button class="pixel-button-flat bg-gray-200 text-black px-2 py-1 text-xs move-substep-up" data-substep-id="${substep.id}" data-goal-id="${goal.id}" title="ä¸Šç§»å­æ­¥éª¤">â†‘</button>
                  <button class="pixel-button-flat bg-gray-200 text-black px-2 py-1 text-xs move-substep-down" data-substep-id="${substep.id}" data-goal-id="${goal.id}" title="ä¸‹ç§»å­æ­¥éª¤">â†“</button>
                  <button class="pixel-button-flat bg-green-500 text-white px-2 py-1 text-xs edit-substep-btn" 
                          data-goal-id="${goal.id}" 
                          data-substep-id="${substep.id}" title="ä¿®æ”¹å­æ­¥éª¤">âœï¸</button>
                  <button class="pixel-button-flat bg-red-500 text-white px-2 py-1 text-xs delete-substep-btn" 
                          data-goal-id="${goal.id}" 
                          data-substep-id="${substep.id}" title="åˆ é™¤å­æ­¥éª¤">ğŸ—‘ï¸</button>
                </div>
              </div>
            `).join('') : ''}
            </div>
          </div>
        `;

        // ç»‘å®šäº‹ä»¶
        bindGoalCardEvents(card, goal, taskId);

        return card;
      }

      // ç»‘å®šç›®æ ‡å¡ç‰‡äº‹ä»¶
      function bindGoalCardEvents(card, goal, taskId) {
        // æ·»åŠ å­æ­¥éª¤
        const addBtn = card.querySelector('.add-substep-btn');
        if (addBtn) {
          addBtn.addEventListener('click', () => openAddSubstepDialog(goal.id, taskId));
        }

        // ä¿®æ”¹ç›®æ ‡
        const editBtn = card.querySelector('.edit-goal-btn');
        if (editBtn) {
          editBtn.addEventListener('click', () => openEditGoalDialog(goal.id, taskId));
        }

        // åˆ é™¤ç›®æ ‡
        const deleteBtn = card.querySelector('.delete-goal-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç›®æ ‡å—ï¼Ÿ')) {
              deleteGoal(taskId, goal.id);
            }
          });
        }

        // å¤é€‰æ¡†äº‹ä»¶
        const checkboxes = card.querySelectorAll('.substep-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.addEventListener('change', function () {
            updateSubstepStatus(
              taskId,
              this.dataset.goalId,
              this.dataset.substepId,
              this.checked
            );
          });
        });

        // ä¿®æ”¹å­æ­¥éª¤æŒ‰é’®
        const editSubstepButtons = card.querySelectorAll('.edit-substep-btn');
        editSubstepButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            openEditSubstepDialog(taskId, btn.dataset.goalId, btn.dataset.substepId);
          });
        });

        // åˆ é™¤å­æ­¥éª¤æŒ‰é’®
        const deleteButtons = card.querySelectorAll('.delete-substep-btn');
        deleteButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­æ­¥éª¤å—ï¼Ÿ')) {
              deleteSubstep(taskId, btn.dataset.goalId, btn.dataset.substepId);
            }
          });
        });

        // ç›®æ ‡ä¸Šç§»/ä¸‹ç§»æŒ‰é’®
        const moveUpBtn = card.querySelector('.move-goal-up');
        const moveDownBtn = card.querySelector('.move-goal-down');
        if (moveUpBtn) moveUpBtn.addEventListener('click', () => moveGoal(taskId, goal.id, 'up'));
        if (moveDownBtn) moveDownBtn.addEventListener('click', () => moveGoal(taskId, goal.id, 'down'));

        // å­æ­¥éª¤ä¸Šç§»/ä¸‹ç§»æŒ‰é’®
        const moveSubUp = card.querySelectorAll('.move-substep-up');
        const moveSubDown = card.querySelectorAll('.move-substep-down');
        moveSubUp.forEach(btn => btn.addEventListener('click', () => moveSubstep(taskId, btn.dataset.goalId, btn.dataset.substepId, 'up')));
        moveSubDown.forEach(btn => btn.addEventListener('click', () => moveSubstep(taskId, btn.dataset.goalId, btn.dataset.substepId, 'down')));

        // æŠ˜å /å±•å¼€å­æ­¥éª¤åŠŸèƒ½
        try {
          const toggleBtn = card.querySelector('.toggle-substeps-btn');
          const wrapper = card.querySelector('.substeps-wrapper');
          const container = wrapper && wrapper.querySelector('.substeps-container');

          // helper: è¯»å–/å†™å…¥ UI prefs
          function getUIPrefs() {
            try {
              const raw = localStorage.getItem('taskpixel_ui');
              return raw ? JSON.parse(raw) : {};
            } catch (e) { return {}; }
          }
          function setUIPrefs(prefs) {
            try { localStorage.setItem('taskpixel_ui', JSON.stringify(prefs)); } catch (e) { }
          }

          if (toggleBtn && container) {
            // åˆå§‹åŒ–æŠ˜å çŠ¶æ€ï¼ˆä¼˜å…ˆä» taskpixel_ui ä¸­è¯»å–ï¼‰
            const prefs = getUIPrefs();
            prefs.collapsedGoals = prefs.collapsedGoals || {};
            prefs.collapsedGoals[taskId] = prefs.collapsedGoals[taskId] || {};
            const collapsed = !!prefs.collapsedGoals[taskId][goal.id];
            container.setAttribute('data-collapsed', collapsed ? 'true' : 'false');
            if (collapsed) container.style.display = 'none';

            toggleBtn.addEventListener('click', () => {
              const isCollapsed = container.getAttribute('data-collapsed') === 'true';
              if (isCollapsed) {
                container.setAttribute('data-collapsed', 'false');
                container.style.display = '';
                toggleBtn.textContent = 'â–¾';
                prefs.collapsedGoals[taskId][goal.id] = false;
              } else {
                container.setAttribute('data-collapsed', 'true');
                container.style.display = 'none';
                toggleBtn.textContent = 'â–¸';
                prefs.collapsedGoals[taskId][goal.id] = true;
              }
              setUIPrefs(prefs);
            });
          }
        } catch (e) {
          console.error('åˆå§‹åŒ–æŠ˜å å­æ­¥éª¤å¤±è´¥', e);
        }
      }

      // æœ¬åœ°å®ç°çš„ç§»åŠ¨å‡½æ•°ï¼ˆå¦‚æœå­˜åœ¨ TaskPixel.TaskDetail åˆ™ä¼˜å…ˆä½¿ç”¨å®ƒï¼‰
      function moveGoal(taskId, goalId, direction) {
        // ä¼˜å…ˆä½¿ç”¨ç»Ÿä¸€çš„ DataStore API
        try {
          if (window.TaskPixel && TaskPixel.DataStore && typeof TaskPixel.DataStore.updateGoalOrder === 'function') {
            const task = TaskPixel.DataStore.getTaskById(taskId);
            if (!task || !task.goals) return;
            const ids = (task.goals || []).slice().sort((a, b) => (a.order || 0) - (b.order || 0)).map(g => g.id);
            const idx = ids.indexOf(goalId);
            if (idx === -1) return;
            if (direction === 'up' && idx > 0) {
              const tmp = ids[idx - 1]; ids[idx - 1] = ids[idx]; ids[idx] = tmp;
            } else if (direction === 'down' && idx < ids.length - 1) {
              const tmp = ids[idx + 1]; ids[idx + 1] = ids[idx]; ids[idx] = tmp;
            } else {
              return;
            }
            TaskPixel.DataStore.updateGoalOrder(taskId, ids);
            // é‡æ–°æ¸²æŸ“æœ€æ–°æ•°æ®
            const refreshed = TaskPixel.DataStore.getTaskById(taskId);
            if (refreshed) renderGoals(refreshed.goals || [], taskId);
            return;
          }
        } catch (e) {
          console.error('moveGoal via DataStore failed', e);
        }

        // å¤‡ç”¨å›é€€ï¼ˆæ—§çš„ localStorage æ“ä½œï¼‰
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (!raw) return;
          const data = JSON.parse(raw);
          const task = data.tasks.find(t => t.id === taskId);
          if (!task || !task.goals) return;
          const ids = task.goals.map(g => g.id);
          const idx = ids.indexOf(goalId);
          if (idx === -1) return;
          if (direction === 'up' && idx > 0) {
            const tmp = task.goals[idx - 1]; task.goals[idx - 1] = task.goals[idx]; task.goals[idx] = tmp;
          } else if (direction === 'down' && idx < task.goals.length - 1) {
            const tmp = task.goals[idx + 1]; task.goals[idx + 1] = task.goals[idx]; task.goals[idx] = tmp;
          }
          task.goals.forEach((g, i) => g.order = i);
          localStorage.setItem('taskpixel_data', JSON.stringify(data));
          renderGoals(task.goals, taskId);
        } catch (e) {
          console.error('moveGoal fallback error', e);
        }
      }

      function moveSubstep(taskId, goalId, substepId, direction) {
        try {
          if (window.TaskPixel && TaskPixel.DataStore && typeof TaskPixel.DataStore.updateSubstepOrder === 'function') {
            const task = TaskPixel.DataStore.getTaskById(taskId);
            if (!task) return;
            const goal = (task.goals || []).find(g => g.id === goalId);
            if (!goal || !goal.substeps) return;
            const ids = (goal.substeps || []).slice().sort((a, b) => (a.order || 0) - (b.order || 0)).map(s => s.id);
            const idx = ids.indexOf(substepId);
            if (idx === -1) return;
            if (direction === 'up' && idx > 0) {
              const tmp = ids[idx - 1]; ids[idx - 1] = ids[idx]; ids[idx] = tmp;
            } else if (direction === 'down' && idx < ids.length - 1) {
              const tmp = ids[idx + 1]; ids[idx + 1] = ids[idx]; ids[idx] = tmp;
            } else {
              return;
            }
            TaskPixel.DataStore.updateSubstepOrder(taskId, goalId, ids);
            const refreshed = TaskPixel.DataStore.getTaskById(taskId);
            if (refreshed) renderGoals(refreshed.goals || [], taskId);
            return;
          }
        } catch (e) {
          console.error('moveSubstep via DataStore failed', e);
        }

        // å¤‡ç”¨å›é€€
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (!raw) return;
          const data = JSON.parse(raw);
          const task = data.tasks.find(t => t.id === taskId);
          if (!task || !task.goals) return;
          const goal = task.goals.find(g => g.id === goalId);
          if (!goal || !goal.substeps) return;
          const ids = goal.substeps.map(s => s.id);
          const idx = ids.indexOf(substepId);
          if (idx === -1) return;
          if (direction === 'up' && idx > 0) {
            const tmp = goal.substeps[idx - 1]; goal.substeps[idx - 1] = goal.substeps[idx]; goal.substeps[idx] = tmp;
          } else if (direction === 'down' && idx < goal.substeps.length - 1) {
            const tmp = goal.substeps[idx + 1]; goal.substeps[idx + 1] = goal.substeps[idx]; goal.substeps[idx] = tmp;
          }
          goal.substeps.forEach((s, i) => s.order = i);
          localStorage.setItem('taskpixel_data', JSON.stringify(data));
          renderGoals(task.goals, taskId);
        } catch (e) {
          console.error('moveSubstep fallback error', e);
        }
      }

      // ç»‘å®šæ·»åŠ ç›®æ ‡äº‹ä»¶
      function bindAddGoalEvents(taskId) {
        const addBtns = document.querySelectorAll('.add-goal-btn');
        addBtns.forEach(btn => {
          btn.addEventListener('click', () => openAddGoalDialog(taskId));
        });
      }

      // æ‰“å¼€æ·»åŠ ç›®æ ‡å¯¹è¯æ¡†
      function openAddGoalDialog(taskId) {
        const dialog = document.createElement('div');
        dialog.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
        dialog.id = 'add-goal-dialog';

        dialog.innerHTML = `
          <div class="pixel-border bg-white p-6 w-full max-w-lg">
            <h2 class="text-2xl font-display mb-6">æ·»åŠ ç›®æ ‡</h2>
            <form id="add-goal-form">
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="goal-title">ç›®æ ‡æ ‡é¢˜ *</label>
                <input type="text" id="goal-title" class="w-full" required placeholder="è¾“å…¥ç›®æ ‡æ ‡é¢˜">
              </div>
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="goal-description">ç›®æ ‡æè¿°</label>
                <textarea id="goal-description" class="w-full h-32" placeholder="è¾“å…¥ç›®æ ‡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
              </div>
              <div class="flex justify-end gap-4">
                <button type="button" id="cancel-add-goal" class="pixel-button">å–æ¶ˆ</button>
                <button type="submit" class="pixel-button bg-primary text-white">æ·»åŠ </button>
              </div>
            </form>
          </div>
        `;

        document.body.appendChild(dialog);

        // ç»‘å®šäº‹ä»¶
        document.getElementById('add-goal-form').addEventListener('submit', function (e) {
          e.preventDefault();
          const title = document.getElementById('goal-title').value.trim();
          const description = document.getElementById('goal-description').value.trim();

          if (!title) {
            alert('è¯·è¾“å…¥ç›®æ ‡æ ‡é¢˜');
            return;
          }

          addGoal(taskId, title, description);
          dialog.remove();
        });

        document.getElementById('cancel-add-goal').addEventListener('click', () => {
          dialog.remove();
        });

        // èšç„¦åˆ°æ ‡é¢˜è¾“å…¥æ¡†
        setTimeout(() => {
          document.getElementById('goal-title').focus();
        }, 100);
      }

      // æ·»åŠ ç›®æ ‡
      function addGoal(taskId, title, description) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (raw) {
            const data = JSON.parse(raw);
            const task = data.tasks.find(t => t.id === taskId);
            if (task) {
              if (!task.goals) task.goals = [];

              const newGoal = {
                id: 'goal-' + Date.now(),
                title: title,
                description: description || '',
                substeps: []
              };

              task.goals.push(newGoal);
              localStorage.setItem('taskpixel_data', JSON.stringify(data));

              // é‡æ–°æ¸²æŸ“
              renderGoals(task.goals, taskId);
            }
          }
        } catch (e) {
          alert('æ·»åŠ ç›®æ ‡å¤±è´¥: ' + e.message);
        }
      }

      // æ‰“å¼€ä¿®æ”¹ç›®æ ‡å¯¹è¯æ¡†
      function openEditGoalDialog(goalId, taskId) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (!raw) return;

          const data = JSON.parse(raw);
          const task = data.tasks.find(t => t.id === taskId);
          if (!task || !task.goals) return;

          const goal = task.goals.find(g => g.id === goalId);
          if (!goal) return;

          const dialog = document.createElement('div');
          dialog.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
          dialog.id = 'edit-goal-dialog';

          dialog.innerHTML = `
            <div class="pixel-border bg-white p-6 w-full max-w-lg">
              <h2 class="text-2xl font-display mb-6">ä¿®æ”¹ç›®æ ‡</h2>
              <form id="edit-goal-form">
                <div class="mb-4">
                  <label class="block font-display text-lg mb-2" for="edit-goal-title">ç›®æ ‡æ ‡é¢˜ *</label>
                  <input type="text" id="edit-goal-title" class="w-full" required placeholder="è¾“å…¥ç›®æ ‡æ ‡é¢˜" value="${goal.title || ''}">
                </div>
                <div class="mb-4">
                  <label class="block font-display text-lg mb-2" for="edit-goal-description">ç›®æ ‡æè¿°</label>
                  <textarea id="edit-goal-description" class="w-full h-32" placeholder="è¾“å…¥ç›®æ ‡æè¿°ï¼ˆå¯é€‰ï¼‰">${goal.description || ''}</textarea>
                </div>
                <div class="flex justify-end gap-4">
                  <button type="button" id="cancel-edit-goal" class="pixel-button">å–æ¶ˆ</button>
                  <button type="submit" class="pixel-button bg-primary text-white">ä¿å­˜</button>
                </div>
              </form>
            </div>
          `;

          document.body.appendChild(dialog);

          // ç»‘å®šäº‹ä»¶
          document.getElementById('edit-goal-form').addEventListener('submit', function (e) {
            e.preventDefault();
            const title = document.getElementById('edit-goal-title').value.trim();
            const description = document.getElementById('edit-goal-description').value.trim();

            if (!title) {
              alert('è¯·è¾“å…¥ç›®æ ‡æ ‡é¢˜');
              return;
            }

            // æ›´æ–°ç›®æ ‡
            goal.title = title;
            goal.description = description;
            localStorage.setItem('taskpixel_data', JSON.stringify(data));

            // é‡æ–°æ¸²æŸ“
            renderGoals(task.goals, taskId);
            dialog.remove();
          });

          document.getElementById('cancel-edit-goal').addEventListener('click', () => {
            dialog.remove();
          });

          // èšç„¦åˆ°æ ‡é¢˜è¾“å…¥æ¡†
          setTimeout(() => {
            document.getElementById('edit-goal-title').focus();
          }, 100);

        } catch (e) {
          alert('ä¿®æ”¹ç›®æ ‡å¤±è´¥: ' + e.message);
        }
      }

      // åˆ é™¤ç›®æ ‡
      function deleteGoal(taskId, goalId) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (raw) {
            const data = JSON.parse(raw);
            const task = data.tasks.find(t => t.id === taskId);
            if (task && task.goals) {
              task.goals = task.goals.filter(g => g.id !== goalId);
              localStorage.setItem('taskpixel_data', JSON.stringify(data));

              // é‡æ–°æ¸²æŸ“
              renderGoals(task.goals, taskId);
              updateProgressBar(taskId);
            }
          }
        } catch (e) {
          alert('åˆ é™¤ç›®æ ‡å¤±è´¥: ' + e.message);
        }
      }

      // æ‰“å¼€æ·»åŠ å­æ­¥éª¤å¯¹è¯æ¡†
      function openAddSubstepDialog(goalId, taskId) {
        const dialog = document.createElement('div');
        dialog.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
        dialog.id = 'add-substep-dialog';

        dialog.innerHTML = `
          <div class="pixel-border bg-white p-6 w-full max-w-lg">
            <h2 class="text-2xl font-display mb-6">æ·»åŠ å­æ­¥éª¤</h2>
            <form id="add-substep-form">
              <div class="mb-4">
                <label class="block font-display text-lg mb-2" for="substep-content">å­æ­¥éª¤å†…å®¹ *</label>
                <input type="text" id="substep-content" class="w-full" required placeholder="è¾“å…¥å­æ­¥éª¤å†…å®¹">
              </div>
              <div class="flex justify-end gap-4">
                <button type="button" id="cancel-add-substep" class="pixel-button">å–æ¶ˆ</button>
                <button type="submit" class="pixel-button bg-primary text-white">æ·»åŠ </button>
              </div>
            </form>
          </div>
        `;

        document.body.appendChild(dialog);

        // ç»‘å®šäº‹ä»¶
        document.getElementById('add-substep-form').addEventListener('submit', function (e) {
          e.preventDefault();
          const content = document.getElementById('substep-content').value.trim();

          if (!content) {
            alert('è¯·è¾“å…¥å­æ­¥éª¤å†…å®¹');
            return;
          }

          addSubstep(goalId, taskId, content);
          dialog.remove();
        });

        document.getElementById('cancel-add-substep').addEventListener('click', () => {
          dialog.remove();
        });

        // èšç„¦åˆ°å†…å®¹è¾“å…¥æ¡†
        setTimeout(() => {
          document.getElementById('substep-content').focus();
        }, 100);
      }

      // æ·»åŠ å­æ­¥éª¤
      function addSubstep(goalId, taskId, content) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (raw) {
            const data = JSON.parse(raw);
            const task = data.tasks.find(t => t.id === taskId);
            if (task && task.goals) {
              const goal = task.goals.find(g => g.id === goalId);
              if (goal) {
                if (!goal.substeps) goal.substeps = [];

                const newSubstep = {
                  id: 'substep-' + Date.now(),
                  content: content,
                  completed: false
                };

                goal.substeps.push(newSubstep);
                localStorage.setItem('taskpixel_data', JSON.stringify(data));

                // é‡æ–°æ¸²æŸ“
                renderGoals(task.goals, taskId);
                updateProgressBar(taskId);
              }
            }
          }
        } catch (e) {
          alert('æ·»åŠ å­æ­¥éª¤å¤±è´¥: ' + e.message);
        }
      }

      // æ‰“å¼€ä¿®æ”¹å­æ­¥éª¤å¯¹è¯æ¡†
      function openEditSubstepDialog(taskId, goalId, substepId) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (!raw) return;

          const data = JSON.parse(raw);
          const task = data.tasks.find(t => t.id === taskId);
          if (!task || !task.goals) return;

          const goal = task.goals.find(g => g.id === goalId);
          if (!goal || !goal.substeps) return;

          const substep = goal.substeps.find(s => s.id === substepId);
          if (!substep) return;

          const dialog = document.createElement('div');
          dialog.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
          dialog.id = 'edit-substep-dialog';

          dialog.innerHTML = `
            <div class="pixel-border bg-white p-6 w-full max-w-lg">
              <h2 class="text-2xl font-display mb-6">ä¿®æ”¹å­æ­¥éª¤</h2>
              <form id="edit-substep-form">
                <div class="mb-4">
                  <label class="block font-display text-lg mb-2" for="edit-substep-content">å­æ­¥éª¤å†…å®¹ *</label>
                  <input type="text" id="edit-substep-content" class="w-full" required placeholder="è¾“å…¥å­æ­¥éª¤å†…å®¹" value="${substep.content || substep.title || ''}">
                </div>
                <div class="mb-4">
                  <label class="flex items-center">
                    <input type="checkbox" id="edit-substep-completed" ${substep.completed ? 'checked' : ''} class="mr-2">
                    <span class="font-display text-lg">å·²å®Œæˆ</span>
                  </label>
                </div>
                <div class="flex justify-end gap-4">
                  <button type="button" id="cancel-edit-substep" class="pixel-button">å–æ¶ˆ</button>
                  <button type="submit" class="pixel-button bg-primary text-white">ä¿å­˜</button>
                </div>
              </form>
            </div>
          `;

          document.body.appendChild(dialog);

          // ç»‘å®šäº‹ä»¶
          document.getElementById('edit-substep-form').addEventListener('submit', function (e) {
            e.preventDefault();
            const content = document.getElementById('edit-substep-content').value.trim();
            const completed = document.getElementById('edit-substep-completed').checked;

            if (!content) {
              alert('è¯·è¾“å…¥å­æ­¥éª¤å†…å®¹');
              return;
            }

            // æ›´æ–°å­æ­¥éª¤
            substep.content = content;
            substep.completed = completed;
            localStorage.setItem('taskpixel_data', JSON.stringify(data));

            // é‡æ–°æ¸²æŸ“
            renderGoals(task.goals, taskId);
            updateProgressBar(taskId);
            dialog.remove();
          });

          document.getElementById('cancel-edit-substep').addEventListener('click', () => {
            dialog.remove();
          });

          // èšç„¦åˆ°å†…å®¹è¾“å…¥æ¡†
          setTimeout(() => {
            document.getElementById('edit-substep-content').focus();
          }, 100);

        } catch (e) {
          alert('ä¿®æ”¹å­æ­¥éª¤å¤±è´¥: ' + e.message);
        }
      }

      // åˆ é™¤å­æ­¥éª¤
      function deleteSubstep(taskId, goalId, substepId) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (raw) {
            const data = JSON.parse(raw);
            const task = data.tasks.find(t => t.id === taskId);
            if (task && task.goals) {
              const goal = task.goals.find(g => g.id === goalId);
              if (goal && goal.substeps) {
                goal.substeps = goal.substeps.filter(s => s.id !== substepId);
                localStorage.setItem('taskpixel_data', JSON.stringify(data));

                // é‡æ–°æ¸²æŸ“
                renderGoals(task.goals, taskId);
                updateProgressBar(taskId);
              }
            }
          }
        } catch (e) {
          alert('åˆ é™¤å­æ­¥éª¤å¤±è´¥: ' + e.message);
        }
      }

      // æ›´æ–°å­æ­¥éª¤çŠ¶æ€
      function updateSubstepStatus(taskId, goalId, substepId, completed) {
        try {
          const raw = localStorage.getItem('taskpixel_data');
          if (raw) {
            const data = JSON.parse(raw);
            const task = data.tasks.find(t => t.id === taskId);
            if (task && task.goals) {
              const goal = task.goals.find(g => g.id === goalId);
              if (goal && goal.substeps) {
                const substep = goal.substeps.find(s => s.id === substepId);
                if (substep) {
                  substep.completed = completed;
                  localStorage.setItem('taskpixel_data', JSON.stringify(data));

                  // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°è¿›åº¦
                  renderGoals(task.goals, taskId);
                  updateProgressBar(taskId);
                }
              }
            }
          }
        } catch (e) {
          alert('æ›´æ–°å­æ­¥éª¤çŠ¶æ€å¤±è´¥: ' + e.message);
        }
      }

      // å†…è”æ ‡ç­¾ç®¡ç†å™¨
      const InlineTagManager = {
        activeInput: null,

        init: function () {
          this.bindEvents();
          console.log('å†…è”æ ‡ç­¾ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        },

        bindEvents: function () {
          // +Tags æŒ‰é’®ç‚¹å‡»äº‹ä»¶
          document.addEventListener('click', (e) => {
            if (e.target.classList.contains('add-tags-btn')) {
              this.showTagInput(e.target);
            }
          });

          // è¾“å…¥æ¡†è¾“å…¥äº‹ä»¶
          document.addEventListener('input', (e) => {
            if (e.target.classList.contains('tag-input-field')) {
              this.handleTagInput(e.target);
            }
          });

          // é”®ç›˜äº‹ä»¶
          document.addEventListener('keydown', (e) => {
            if (e.target.classList.contains('tag-input-field')) {
              this.handleKeydown(e);
            }
          });

          // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­è¾“å…¥æ¡†
          document.addEventListener('click', (e) => {
            if (!e.target.closest('.tags-input-container')) {
              this.hideAllTagInputs();
            }
          });
        },

        // æ˜¾ç¤ºæ ‡ç­¾è¾“å…¥æ¡†
        showTagInput: function (button) {
          this.hideAllTagInputs();

          const container = button.closest('.tags-input-container');
          const wrapper = container.querySelector('.tag-input-wrapper');
          const input = wrapper.querySelector('.tag-input-field');

          button.classList.add('hidden');
          wrapper.classList.remove('hidden');

          setTimeout(() => {
            input.focus();
            this.activeInput = input;
          }, 50);
        },

        // éšè—æ‰€æœ‰æ ‡ç­¾è¾“å…¥æ¡†
        hideAllTagInputs: function () {
          document.querySelectorAll('.tags-input-container').forEach(container => {
            const button = container.querySelector('.add-tags-btn');
            const wrapper = container.querySelector('.tag-input-wrapper');
            const input = wrapper.querySelector('.tag-input-field');
            const suggestions = wrapper.querySelector('.tag-suggestions');

            button.classList.remove('hidden');
            wrapper.classList.add('hidden');
            suggestions.classList.add('hidden');
            input.value = '';
          });

          this.activeInput = null;
        },

        // å¤„ç†æ ‡ç­¾è¾“å…¥
        handleTagInput: function (input) {
          const query = input.value.trim();
          if (query.length === 0) {
            this.hideSuggestions(input);
            return;
          }

          // è·å–ç°æœ‰æ ‡ç­¾è¿›è¡Œæœç´¢
          const existingTags = this.getAllTags();
          const filteredTags = existingTags.filter(tag =>
            tag.name.toLowerCase().includes(query.toLowerCase())
          );

          this.showSuggestions(input, filteredTags, query);
        },

        // å¤„ç†é”®ç›˜äº‹ä»¶
        handleKeydown: function (e) {
          const input = e.target;
          const suggestions = input.parentElement.querySelector('.tag-suggestions');

          if (e.key === 'Escape') {
            this.hideAllTagInputs();
            return;
          }

          if (e.key === 'Enter') {
            e.preventDefault();
            const selectedItem = suggestions.querySelector('.tag-suggestion-item.selected');

            if (selectedItem) {
              if (selectedItem.dataset.tagId === 'create-new') {
                this.createAndAddTag(input, selectedItem.dataset.tagName);
              } else {
                this.selectTag(input, selectedItem.dataset.tagId);
              }
            } else {
              const query = input.value.trim();
              if (query) {
                this.createAndAddTag(input, query);
              }
            }
            return;
          }

          if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            this.navigateSuggestions(suggestions, e.key === 'ArrowDown');
            return;
          }
        },

        // æ˜¾ç¤ºå»ºè®®
        showSuggestions: function (input, tags, query) {
          const suggestions = input.parentElement.querySelector('.tag-suggestions');
          suggestions.innerHTML = '';

          // æ·»åŠ ç°æœ‰æ ‡ç­¾å»ºè®®
          tags.forEach(tag => {
            const item = document.createElement('div');
            item.className = 'tag-suggestion-item';
            item.dataset.tagId = tag.id;
            // ä½¿ç”¨ fallback æœºåˆ¶ç¡®ä¿æ ‡ç­¾æ˜¾ç¤º
            const displayText = tag.display_text || '#' + tag.name || '#' + tag.id;
            item.innerHTML = `<span style="color: ${tag.color || '#374151'}">${displayText}</span>`;
            item.addEventListener('click', () => this.selectTag(input, tag.id));
            suggestions.appendChild(item);
          });

          // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å®Œå…¨åŒ¹é…çš„æ ‡ç­¾
          const existingTags = this.getAllTags();
          const exactMatch = existingTags.find(tag =>
            tag.name.toLowerCase() === query.toLowerCase()
          );

          // å¦‚æœæ²¡æœ‰åŒ¹é…çš„æ ‡ç­¾ä¸”æ²¡æœ‰å®Œå…¨åŒ¹é…çš„æ ‡ç­¾ï¼Œæ˜¾ç¤ºåˆ›å»ºæ–°æ ‡ç­¾é€‰é¡¹
          if (tags.length === 0 && query && !exactMatch) {
            const createItem = document.createElement('div');
            createItem.className = 'tag-suggestion-item';
            createItem.dataset.tagId = 'create-new';
            createItem.dataset.tagName = query;
            createItem.innerHTML = `åˆ›å»ºæ–°æ ‡ç­¾: <strong>#${query}</strong>`;
            createItem.addEventListener('click', () => this.createAndAddTag(input, query));
            suggestions.appendChild(createItem);
          } else if (exactMatch && tags.length === 0) {
            // å¦‚æœæœ‰å®Œå…¨åŒ¹é…ä½†ä¸åœ¨è¿‡æ»¤ç»“æœä¸­ï¼Œæ˜¾ç¤ºè¯¥æ ‡ç­¾
            const item = document.createElement('div');
            item.className = 'tag-suggestion-item';
            item.dataset.tagId = exactMatch.id;
            item.innerHTML = `<span style="color: ${exactMatch.color || '#374151'}">#${exactMatch.name}</span>`;
            item.addEventListener('click', () => this.selectTag(input, exactMatch.id));
            suggestions.appendChild(item);
          }

          suggestions.classList.remove('hidden');
        },

        // éšè—å»ºè®®
        hideSuggestions: function (input) {
          const suggestions = input.parentElement.querySelector('.tag-suggestions');
          suggestions.classList.add('hidden');
        },

        // å¯¼èˆªå»ºè®®åˆ—è¡¨
        navigateSuggestions: function (suggestions, isDown) {
          const items = suggestions.querySelectorAll('.tag-suggestion-item');
          if (items.length === 0) return;

          const currentSelected = suggestions.querySelector('.tag-suggestion-item.selected');
          let newIndex = 0;

          if (currentSelected) {
            currentSelected.classList.remove('selected');
            const currentIndex = Array.from(items).indexOf(currentSelected);

            if (isDown) {
              newIndex = (currentIndex + 1) % items.length;
            } else {
              newIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1;
            }
          }

          items[newIndex].classList.add('selected');
        },

        // é€‰æ‹©æ ‡ç­¾
        selectTag: function (input, tagId) {
          const container = input.closest('.tags-input-container');
          const target = container.dataset.target;
          const taskId = container.dataset.taskId;
          const goalId = container.dataset.goalId;

          if (target === 'task') {
            this.addTagToTask(taskId, tagId);
          } else if (target === 'goal') {
            this.addTagToGoal(taskId, goalId, tagId);
          }

          this.hideAllTagInputs();
        },

        // åˆ›å»ºå¹¶æ·»åŠ æ–°æ ‡ç­¾
        createAndAddTag: function (input, tagName) {
          // ä½¿ç”¨TagManageråˆ›å»ºæ–°æ ‡ç­¾
          if (window.TaskPixel && window.TaskPixel.TagManager) {
            const result = window.TaskPixel.TagManager.createTag({ name: tagName });
            if (result.success) {
              this.selectTag(input, result.tagId);
            } else if (result.reason === 'tag_exists') {
              this.selectTag(input, result.tagId);
            } else {
              alert('åˆ›å»ºæ ‡ç­¾å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
          } else {
            // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥åˆ›å»ºç®€å•æ ‡ç­¾
            const cleanTagName = tagName.replace(/^#/, "").trim();

            // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦å·²å­˜åœ¨
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            if (!data.tags) data.tags = [];

            const existingTag = data.tags.find(tag => tag.name.toLowerCase() === cleanTagName.toLowerCase());
            if (existingTag) {
              // å¦‚æœæ ‡ç­¾å·²å­˜åœ¨ï¼Œç›´æ¥é€‰æ‹©ç°æœ‰æ ‡ç­¾
              this.selectTag(input, existingTag.id);
              return;
            }

            const newTag = {
              id: 'tag-' + Date.now(),
              name: cleanTagName,
              display_text: '#' + cleanTagName,
              color: this.getRandomTagColor(),
              created_at: new Date().toISOString(),
              usage_count: 0
            };

            data.tags.push(newTag);
            localStorage.setItem('taskpixel_data', JSON.stringify(data));

            // é€šçŸ¥ DataStore é‡æ–°åŠ è½½æ•°æ®
            if (typeof TaskPixel !== 'undefined' && TaskPixel.DataStore) {
              TaskPixel.DataStore.loadFromStorage();
            }

            // ä½¿ TagManager ç¼“å­˜å¤±æ•ˆ
            if (typeof TaskPixel !== 'undefined' && TaskPixel.TagManager) {
              TaskPixel.TagManager.invalidateCache();
            }

            this.selectTag(input, newTag.id);
          }
        },

        // è·å–æ‰€æœ‰æ ‡ç­¾
        getAllTags: function () {
          try {
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            return data.tags || [];
          } catch (e) {
            return [];
          }
        },

        // è·å–éšæœºæ ‡ç­¾é¢œè‰²
        getRandomTagColor: function () {
          const colors = ['#374151', '#6B7280', '#4B5563', '#1F2937', '#065F46', '#7C2D12', '#581C87', '#92400E'];
          return colors[Math.floor(Math.random() * colors.length)];
        },

        // æ·»åŠ æ ‡ç­¾åˆ°ä»»åŠ¡
        addTagToTask: function (taskId, tagId) {
          try {
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            const task = data.tasks?.find(t => t.id === taskId);

            if (task) {
              if (!task.tags) task.tags = [];
              if (!task.tags.includes(tagId)) {
                task.tags.push(tagId);
                localStorage.setItem('taskpixel_data', JSON.stringify(data));

                // é€šçŸ¥ DataStore é‡æ–°åŠ è½½æ•°æ®
                if (typeof TaskPixel !== 'undefined' && TaskPixel.DataStore) {
                  TaskPixel.DataStore.loadFromStorage();
                }

                this.renderTaskTags(taskId);
              }
            }
          } catch (e) {
            console.error('æ·»åŠ ä»»åŠ¡æ ‡ç­¾å¤±è´¥:', e);
          }
        },

        // æ·»åŠ æ ‡ç­¾åˆ°ç›®æ ‡
        addTagToGoal: function (taskId, goalId, tagId) {
          try {
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            const task = data.tasks?.find(t => t.id === taskId);
            const goal = task?.goals?.find(g => g.id === goalId);

            if (goal) {
              if (!goal.tags) goal.tags = [];
              if (!goal.tags.includes(tagId)) {
                goal.tags.push(tagId);
                localStorage.setItem('taskpixel_data', JSON.stringify(data));

                // é€šçŸ¥ DataStore é‡æ–°åŠ è½½æ•°æ®
                if (typeof TaskPixel !== 'undefined' && TaskPixel.DataStore) {
                  TaskPixel.DataStore.loadFromStorage();
                }

                this.renderGoalTags(goalId);
              }
            }
          } catch (e) {
            console.error('æ·»åŠ ç›®æ ‡æ ‡ç­¾å¤±è´¥:', e);
          }
        },

        // æ¸²æŸ“ä»»åŠ¡æ ‡ç­¾
        renderTaskTags: function (taskId) {
          try {
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            const task = data.tasks?.find(t => t.id === taskId);
            const allTags = data.tags || [];

            const container = document.querySelector('.task-tags-display');
            if (!container || !task) return;

            container.innerHTML = '';

            if (task.tags && task.tags.length > 0) {
              task.tags.forEach(tagId => {
                const tag = allTags.find(t => t.id === tagId);
                if (tag) {
                  const tagElement = this.createTagElement(tag, () => this.removeTagFromTask(taskId, tagId));
                  container.appendChild(tagElement);
                }
              });
            }
          } catch (e) {
            console.error('æ¸²æŸ“ä»»åŠ¡æ ‡ç­¾å¤±è´¥:', e);
          }
        },

        // æ¸²æŸ“ç›®æ ‡æ ‡ç­¾
        renderGoalTags: function (goalId) {
          try {
            const data = JSON.parse(localStorage.getItem('taskpixel_data') || '{}');
            const allTags = data.tags || [];

            // æ‰¾åˆ°ç›®æ ‡
            let goal = null;
            for (const task of data.tasks || []) {
              const foundGoal = task.goals?.find(g => g.id === goalId);
              if (foundGoal) {
                goal = foundGoal;
                break;
              }
            }

            const container = document.querySelector(`[data-goal-id="${goalId}"] .goal-tags-display`);
            if (!container || !goal) return;

            container.innerHTML = '';

            if (goal.tags && goal.tags.length > 0) {
              goal.tags.forEach(tagId => {
                const tag = allTags.find(t => t.id === tagId);
                if (tag) {
                  const tagElement = this.createTagElement(tag, () => this.removeTagFromGoal(goalId, tagId));
                  container.appendChild(tagElement);
                }
              });
            }
          } catch (e) {
            console.error('æ¸²æŸ“ç›®æ ‡æ ‡ç­¾å¤±è´¥:', e);
          }
        },

        // åˆ›å»ºæ ‡ç­¾å…ƒç´ 
        createTagElement: function (tag, onRemove) {
          const tagElement = document.createElement('span');
          tagElement.className = 'task-tag';
          tagElement.style.color = tag.color || '#374151';
          // ä½¿ç”¨ fallback æœºåˆ¶ç¡®ä¿æ ‡ç­¾æ˜¾ç¤º
          const displayText = tag.display_text || '#' + tag.name || '#' + tag.id;
          tagElement.textContent = displayText;
          tagElement.title = 'ç‚¹å‡»ä»ä»»åŠ¡ä¸­ç§»é™¤æ­¤æ ‡ç­¾';

          tagElement.addEventListener('click', (e) => {
            e.preventDefault();
            if (confirm(`ç¡®å®šè¦ä»æ­¤ä»»åŠ¡ä¸­ç§»é™¤æ ‡ç­¾ ${displayText} å—ï¼Ÿ\n\næ³¨æ„ï¼šè¿™åªä¼šä»å½“å‰ä»»åŠ¡ä¸­ç§»é™¤æ ‡ç­¾ï¼Œä¸ä¼šåˆ é™¤æ ‡ç­¾æœ¬èº«ã€‚`)) {
              onRemove();
            }
          });

          return tagElement;
        },

        // ä»ä»»åŠ¡ç§»é™¤æ ‡ç­¾
        removeTagFromTask: function (taskId, tagId) {
          try {
            // ä½¿ç”¨ DataStore API è€Œä¸æ˜¯ç›´æ¥æ“ä½œ localStorage
            const task = TaskPixel.DataStore.getTaskById(taskId);

            if (task && task.tags) {
              task.tags = task.tags.filter(id => id !== tagId);
              // ä½¿ç”¨ DataStore çš„ä¿å­˜æ–¹æ³•ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
              TaskPixel.DataStore.saveToStorage();
              this.renderTaskTags(taskId);

              // è§¦å‘äº‹ä»¶é€šçŸ¥å…¶ä»–ç»„ä»¶
              TaskPixel.EventBus.emit("task:tags_updated", {
                taskId: taskId,
                tags: task.tags,
              });
            }
          } catch (e) {
            console.error('ç§»é™¤ä»»åŠ¡æ ‡ç­¾å¤±è´¥:', e);
          }
        },

        // ä»ç›®æ ‡ç§»é™¤æ ‡ç­¾
        removeTagFromGoal: function (goalId, tagId) {
          try {
            // ä½¿ç”¨ DataStore API è€Œä¸æ˜¯ç›´æ¥æ“ä½œ localStorage
            const tasks = TaskPixel.DataStore.getAllTasks();

            // æ‰¾åˆ°å¹¶æ›´æ–°ç›®æ ‡
            for (const task of tasks) {
              const goal = task.goals?.find(g => g.id === goalId);
              if (goal && goal.tags) {
                goal.tags = goal.tags.filter(id => id !== tagId);
                // ä½¿ç”¨ DataStore çš„ä¿å­˜æ–¹æ³•ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
                TaskPixel.DataStore.saveToStorage();
                this.renderGoalTags(goalId);

                // è§¦å‘äº‹ä»¶é€šçŸ¥å…¶ä»–ç»„ä»¶
                TaskPixel.EventBus.emit("goal:tags_updated", {
                  goalId: goalId,
                  tags: goal.tags,
                });
                break;
              }
            }
          } catch (e) {
            console.error('ç§»é™¤ç›®æ ‡æ ‡ç­¾å¤±è´¥:', e);
          }
        }
      };

      // å†…è”æ ‡ç­¾ç®¡ç†å™¨åˆå§‹åŒ–å°†åœ¨å®šä¹‰åè¿›è¡Œ

      // æ›´æ–°è¿›åº¦æ¡
      function updateProgressBar(taskId) {
        if (!taskId) {
          console.warn('updateProgressBar: taskId is missing');
          return;
        }

        setTimeout(() => {
          try {
            // è·å–å®é™…è¿›åº¦
            let actualProgress = 0;

            if (window.TaskPixel?.DataStoreAdapter?.getTaskProgress) {
              actualProgress = window.TaskPixel.DataStoreAdapter.getTaskProgress(taskId);
            } else {
              // å¤‡ç”¨è®¡ç®—æ–¹æ³•
              const raw = localStorage.getItem('taskpixel_data');
              if (raw) {
                const data = JSON.parse(raw);
                const task = data.tasks?.find(t => t.id === taskId);
                if (task) {
                  // è®¡ç®—åŸºäºç›®æ ‡å’Œå­æ­¥éª¤çš„è¿›åº¦
                  let totalSubsteps = 0;
                  let completedSubsteps = 0;

                  if (task.goals && Array.isArray(task.goals)) {
                    task.goals.forEach(goal => {
                      if (goal.substeps && Array.isArray(goal.substeps)) {
                        goal.substeps.forEach(substep => {
                          totalSubsteps++;
                          if (substep.completed) {
                            completedSubsteps++;
                          }
                        });
                      }
                    });
                  }

                  actualProgress = totalSubsteps > 0 ? Math.round((completedSubsteps / totalSubsteps) * 100) : 0;
                }
              }
            }

            // æ›´æ–°è¿›åº¦æ¡
            const progressEl = document.querySelector('.progress-bar-fill');
            const progressTextEl = document.querySelector('.progress-text');

            if (progressEl) {
              progressEl.style.width = actualProgress + '%';
            }
            if (progressTextEl) {
              progressTextEl.textContent = actualProgress + '% å®Œæˆ';
            }
            // æ›´æ–°å†…éƒ¨æ ‡ç­¾ï¼ˆè‹¥å­˜åœ¨ï¼‰
            const progressLabelEl = document.querySelector('.progress-label');
            if (progressLabelEl) {
              progressLabelEl.textContent = actualProgress + '%';
              if (actualProgress < 10) {
                progressLabelEl.classList.add('hidden-small');
              } else {
                progressLabelEl.classList.remove('hidden-small');
              }
            }

          } catch (e) {
            console.error('Error updating progress bar:', e);
          }
        }, 100);
      }

      // åˆå§‹åŒ–å†…è”æ ‡ç­¾ç®¡ç†å™¨
      InlineTagManager.init();

    });
  </script>
</body>

</html>